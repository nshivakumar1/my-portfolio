---
// blogs.astro
import Layout from '../layouts/Layout.astro';
import Parser from 'rss-parser';

// Define a type for the post items
interface SubstackPost {
  title: string;
  link: string;
  pubDate?: string;
  contentSnippet?: string;
  // Add other properties as needed
}

// Create a function to fetch Substack posts with proper error handling
async function getSubstackPosts(): Promise<SubstackPost[]> {
  // Configure parser with more lenient options
  const parser = new Parser({
    customFields: {
      item: ['content:encoded', 'description']
    },
    // Add timeout to prevent hanging
    timeout: 5000,
    // More lenient XML parsing
    xml2js: {
      // Make XML parsing more tolerant of errors
      strict: false,
      normalize: true,
      normalizeTags: true,
      // Skip attributes that cause issues
      ignoreAttrs: true
    }
  });
  
  // Replace with your actual Substack URL - using Medium as a fallback for testing
  // You can change this to your actual Substack URL later
  const substackUrl = 'https://substack.com/@codeclouddevops/posts';
  
  try {
    // Try direct fetch first
    const feed = await parser.parseURL(substackUrl);
    return (feed.items as SubstackPost[]) || [];
  } catch (error: unknown) {
    console.error("Direct feed fetch failed, trying workaround...");
    
    try {
      // Fallback to fetch API with manual parsing if direct method fails
      const response = await fetch(substackUrl);
      if (!response.ok) {
        throw new Error(`Failed to fetch: ${response.status}`);
      }
      
      const xmlText = await response.text();
      const feed = await parser.parseString(xmlText);
      return (feed.items as SubstackPost[]) || [];
    } catch (fallbackError: unknown) {
      // Log both errors for debugging
      if (error instanceof Error) {
        console.error(`Original error: ${error.message}`);
      }
      
      if (fallbackError instanceof Error) {
        console.error(`Fallback error: ${fallbackError.message}`);
      }
      
      // Return mock data so the page doesn't break
      return [
        {
          title: "Coming Soon",
          link: "#",
          pubDate: new Date().toISOString(),
          contentSnippet: "Blog posts will be available soon. Check back later!"
        }
      ];
    }
  }
}

// Get posts with error handling - DECLARE ONLY ONCE
const posts = await getSubstackPosts();
---

<Layout title="Blog Posts">
  <main>
    <h1>Blog Posts</h1>
    
    {posts.length > 0 ? (
      <div class="posts-container">
        {posts.map((post) => (
          <div class="post-card">
            <h2>{post.title}</h2>
            {post.pubDate && (
              <p class="date">
                {new Date(post.pubDate).toLocaleDateString('en-US', {
                  year: 'numeric',
                  month: 'long', 
                  day: 'numeric'
                })}
              </p>
            )}
            {post.contentSnippet && (
              <p>{post.contentSnippet.substring(0, 150)}...</p>
            )}
            <a href={post.link} target="_blank" rel="noopener noreferrer">Read more</a>
          </div>
        ))}
      </div>
    ) : (
      <div class="no-posts">
        <p>No blog posts available at the moment. Check back soon!</p>
      </div>
    )}
  </main>
</Layout>

<style>
  .posts-container {
    display: grid;
    gap: 2rem;
    margin: 2rem 0;
  }
  
  .post-card {
    border: 1px solid #eaeaea;
    border-radius: 8px;
    padding: 1.5rem;
    background-color: #fff;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  }
  
  .date {
    color: #666;
    font-size: 0.9rem;
  }
  
  .no-posts {
    text-align: center;
    padding: 3rem 0;
  }
</style>